var potion = (function () {
    'use strict';

    /**
     * @module filters
     */

    const filters = {};

    /**
     * Ajoute un filtre pour la substitution des tokens.
     *
     * @param {string} name - Le nom du filtre.
     * @param {function} fn - La fonction de filtre.
     * @param {number} [priority=0] - La priorité d'exécution.
     * @throws {TypeError} Si le nom n'est pas une chaîne ou si fn n'est pas une fonction.
     */
    function addFilter(name, fn, priority = 0) {
        if (typeof name !== "string" || typeof fn !== "function") {
            throw new TypeError(
                "Invalid arguments: 'name' must be a string and 'fn' must be a function."
            );
        }
        filters[name] = filters[name] || [];
        filters[name].push([fn, priority]);
        filters[name].sort((a, b) => a[1] - b[1]);
    }

    /**
     * Applique un filtre sur un payload donné.
     *
     * @param {string} name - Le nom du filtre.
     * @param {*} payload - La valeur initiale.
     * @param {...*} args - Arguments additionnels pour le filtre.
     * @returns {*} Le résultat après application des filtres.
     */
    function applyFilter(name, payload, ...args) {
        return (filters[name] || []).reduce((result, [fn]) => {
            const substituted = fn(result, ...args);
            return substituted !== undefined ? substituted : "";
        }, payload);
    }

    // Filtre par défaut pour la substitution des tokens
    addFilter("token", (token, data, tag) => {
        const path = token.split(".");
        let dataLookup = data;
        for (let i = 0; i < path.length; i++) {
            if (!Object.prototype.hasOwnProperty.call(dataLookup, path[i])) {
                return "";
            }
            dataLookup = dataLookup[path[i]];
        }
        if (dataLookup instanceof HTMLElement) {
            return dataLookup.outerHTML;
        }
        return dataLookup;
    });

    /**
     * Filtres pour string
     */

    addFilter("uppercase", (value) =>
        typeof value === "string" ? value.toUpperCase() : value
    );

    addFilter("lowercase", (value) =>
        typeof value === "string" ? value.toLowerCase() : value
    );

    addFilter("capitalize", (value) =>
        typeof value === "string"
            ? value.charAt(0).toUpperCase() + value.slice(1)
            : value
    );

    addFilter("truncate", (value, data, template, length = 50, ellipsis = "") =>
        typeof value === "string" && value.length > length
            ? value.slice(0, length) + ellipsis
            : value
    );

    addFilter("trim", (value) =>
        typeof value === "string" ? value.trim() : value
    );

    addFilter("lstrip", (value) =>
        typeof value === "string" ? value.replace(/^\s+/, "") : value
    );

    addFilter("append", (value, data, template, suffix) =>
        typeof value === "string" ? value + suffix : value
    );

    addFilter("default", (value, data, template, defaultValue) =>
        value === null || value === undefined || value === "" ? defaultValue : value
    );

    /**
     * Filtres pour nombre
     */

    addFilter("abs", (value) =>
        typeof value === "number" ? Math.abs(value) : value
    );

    addFilter("at_least", (value, data, template, min) =>
        typeof value === "number" ? Math.max(value, Number(min)) : value
    );

    addFilter("at_most", (value, data, template, max) =>
        typeof value === "number" ? Math.min(value, Number(max)) : value
    );

    addFilter("ceil", (value) =>
        typeof value === "number" ? Math.ceil(value) : value
    );

    addFilter("floor", (value) =>
        typeof value === "number" ? Math.floor(value) : value
    );

    addFilter("divided_by", (value, data, template, divisor) =>
        typeof Number(value) === "number" && Number(divisor) !== 0
            ? value / Number(divisor)
            : value
    );

    addFilter("escape", (value) =>
        typeof value === "string"
            ? value
                  .replace(/&/g, "&amp;")
                  .replace(/</g, "&lt;")
                  .replace(/>/g, "&gt;")
                  .replace(/"/g, "&quot;")
                  .replace(/'/g, "&#39;")
            : value
    );

    /**
     * Filtres pour tableaux
     */
    addFilter("compact", (value) =>
        Array.isArray(value)
            ? value.filter((item) => item !== null && item !== undefined)
            : value
    );
    addFilter("first", (value) => {
        if (Array.isArray(value)) return value[0];
        if (typeof value === "string") return value.charAt(0);
        return value;
    });
    addFilter("last", (value) => {
        if (Array.isArray(value)) return value[value.length - 1];
        if (typeof value === "string") return value.charAt(value.length - 1);
        return value;
    });
    addFilter("join", (value, data, template, delimiter) =>
        Array.isArray(value) ? value.join(delimiter || "") : value
    );
    addFilter("map", (value, data, template, property) =>
        Array.isArray(value) ? value.map((item) => item[property]) : value
    );

    /**
     * @module utils
     */

    /**
     * Échappe une chaîne pour être utilisée dans une expression régulière.
     * @param {string} string La chaîne à échapper.
     * @returns {string} La chaîne échappée.
     */
    function escapeRegex(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    /**
     * Vérifie si une chaîne correspond à un tag HTML valide.
     *
     * @param {string} tagName Le nom du tag à tester.
     * @returns {boolean} true si c'est un élément valide, false sinon.
     */
    function isValidHTMLElement(tagName) {
        const el = document.createElement(tagName);
        return !(el instanceof HTMLUnknownElement);
    }

    const ud = typeof _userdata !== "undefined" ? _userdata : {};

    /**
     * @module store
     * @description Objet global servant de store.
     */
    const store = {
        user: {
            name: ud?.username,
            logged_in: Boolean(ud?.session_logged_in),
            level: ud?.user_level,
            id: ud?.user_id,
            posts: ud?.user_posts,
            avatar: ud?.avatar,
            avatar_link: ud?.avatar_link,
            group_color: ud?.groupcolor,
        },
    };

    const extendStore = (data) => {
        return Object.assign({ $store: store }, data);
    };

    /**
     * @module parser
     */


    let uniqueCounter = 0;
    const localContexts = new Map();

    // Cache pour la tokenisation des templates
    const tokenCache = new Map();

    /**
     * Analyse un template et le découpe en segments statiques et tokens.
     * Chaque token est représenté par un objet { type: "token", value, flag }.
     *
     * @param {string} template La chaîne du template.
     * @param {Object} settings La configuration (start, end, path).
     * @returns {Array<Object>} Le tableau des segments.
     */
    function tokenizeTemplate(template, settings) {
        // Le pattern capture un flag optionnel ("!" ou "/") suivi du token.
        const pattern = new RegExp(
            `${escapeRegex(settings.start)}\\s*([!\\/]?)\\s*(${
            settings.path
        })\\s*${escapeRegex(settings.end)}`,
            "gi"
        );
        let tokens = [];
        let lastIndex = 0;
        let match;
        while ((match = pattern.exec(template)) !== null) {
            // Ajoute le segment statique avant le token
            if (match.index > lastIndex) {
                tokens.push({
                    type: "static",
                    value: template.slice(lastIndex, match.index),
                });
            }
            // Ajoute le token, avec match[1] comme flag ("" pour ouverture, "/" pour fermeture, éventuellement "!")
            tokens.push({
                type: "token",
                flag: match[1],
                value: match[2],
            });
            lastIndex = pattern.lastIndex;
        }
        // Ajoute le reste du template s'il existe
        if (lastIndex < template.length) {
            tokens.push({
                type: "static",
                value: template.slice(lastIndex),
            });
        }
        return tokens;
    }

    /**
     * Retourne les tokens pour un template donné en utilisant le cache.
     *
     * @param {string} template Le template à tokeniser.
     * @param {Object} settings Les paramètres de configuration.
     * @returns {Array<Object>} Le tableau des tokens.
     */
    function getTokens(template, settings) {
        if (tokenCache.has(template)) {
            return tokenCache.get(template);
        }
        const tokens = tokenizeTemplate(template, settings);
        tokenCache.set(template, tokens);
        return tokens;
    }

    // Fonction pour extraire les templates imbriqués et les protéger
    function protectNestedTemplates(templateStr) {
        const nestedTemplates = {};
        let counter = 0;
        // On utilise une regex qui capture les balises <template> imbriquées
        const regex = /<template\b[^>]*>([\s\S]*?)<\/template>/gi;
        const protectedStr = templateStr.replace(regex, (match) => {
            const placeholder = `__NESTED_TEMPLATE_${counter}__`;
            nestedTemplates[placeholder] = match;
            counter++;
            return placeholder;
        });
        return { protectedStr, nestedTemplates };
    }

    // Fonction pour restaurer les templates imbriqués après substitution
    function restoreNestedTemplates(templateStr, nestedTemplates) {
        for (const placeholder in nestedTemplates) {
            templateStr = templateStr.replace(
                placeholder,
                nestedTemplates[placeholder]
            );
        }
        return templateStr;
    }

    // Fonction de substitution "protégée"
    function safeSubstitute(templateStr, data, settings) {
        // Protéger les templates imbriqués
        const { protectedStr, nestedTemplates } =
            protectNestedTemplates(templateStr);
        // Appliquer la substitution sur le contenu protégé
        let substituted = substitute(protectedStr, data, settings);
        // Restaurer les templates imbriqués intacts
        substituted = restoreNestedTemplates(substituted, nestedTemplates);
        return substituted;
    }

    function parseFilterArguments(argString) {
        // On commence par trimper l'ensemble de la chaîne d'arguments
        argString = argString.trim();
        const args = [];
        // Ce regex capture :
        //  • un argument entre guillemets doubles : "([^"]*)"
        //  • ou entre guillemets simples : '([^']*)'
        //  • ou un argument non cité : ([^,]+)
        // suivis d'une virgule optionnelle et d'espaces
        const regex = /(?:"([^"]*)"|'([^']*)'|([^,]+))(?:,\s*)?/g;
        let match;
        while ((match = regex.exec(argString)) !== null) {
            if (match[1] !== undefined) {
                // Argument entre guillemets doubles (le groupe 1 ne contient pas les quotes)
                args.push(match[1]);
            } else if (match[2] !== undefined) {
                // Argument entre guillemets simples
                args.push(match[2]);
            } else if (match[3] !== undefined) {
                // Argument non cité, on applique trim
                args.push(match[3].trim());
            }
        }
        return args;
    }

    /**
     * Effectue la substitution sur un template en utilisant les tokens pré-analyzés,
     * et gère les blocs conditionnels et les boucles.
     *
     * @param {string} template Le template original.
     * @param {Object} data Les données pour la substitution.
     * @param {Object} settings La configuration (start, end, path).
     * @returns {string} Le template rendu.
     */
    function substitute(template, data, settings) {
        const tokens = getTokens(template, settings);
        let output = "";
        let index = 0;

        while (index < tokens.length) {
            const segment = tokens[index];

            if (segment.type === "static") {
                output += segment.value;
                index++;
            } else if (segment.type === "token") {
                // Ignore le token de fermeture
                if (segment.flag === "/") {
                    index++;
                    continue;
                }

                // Découpe la valeur du token pour extraire la clé et la chaîne de filtres
                const parts = segment.value.split("|").map((s) => s.trim());
                const tokenKey = parts[0];

                // Recherche d'un bloc de fermeture associé (pour les blocs conditionnels ou les boucles)
                let innerTokens = [];
                let j = index + 1;
                let foundClosing = false;
                while (j < tokens.length) {
                    const nextSegment = tokens[j];
                    // Pour la fermeture, on compare uniquement la clé sans filtres
                    if (
                        nextSegment.type === "token" &&
                        nextSegment.flag === "/" &&
                        nextSegment.value.trim() === tokenKey
                    ) {
                        foundClosing = true;
                        break;
                    }
                    innerTokens.push(nextSegment);
                    j++;
                }

                let substituted;
                try {
                    // On récupère la valeur initiale du token via le filtre par défaut "token"
                    substituted = applyFilter("token", tokenKey, data, template);
                } catch (e) {
                    console.warn(e.message);
                    substituted = "";
                }

                // Si des filtres additionnels sont présents, on les applique successivement
                for (let i = 1; i < parts.length; i++) {
                    let filterSpec = parts[i]; // ex. "truncate: 100, \"…\"" ou "join: ', '"
                    let filterName = filterSpec;
                    let filterArgs = [];
                    if (filterSpec.indexOf(":") !== -1) {
                        let [name, argString] = filterSpec.split(":", 2);
                        filterName = name.trim();
                        // Utilisation de la fonction dédiée pour parser les arguments
                        filterArgs = parseFilterArguments(argString);
                    }
                    substituted = applyFilter(
                        filterName,
                        substituted,
                        data,
                        template,
                        ...filterArgs
                    );
                }

                if (foundClosing) {
                    // Cas d'un bloc
                    const innerTemplate = innerTokens
                        .map((tok) =>
                            tok.type === "static"
                                ? tok.value
                                : `${settings.start}${tok.flag ? tok.flag : ""}${
                                  tok.value
                              }${settings.end}`
                        )
                        .join("");

                    if (typeof substituted === "boolean") {
                        output += substituted
                            ? substitute(innerTemplate, data, settings)
                            : "";
                    } else if (typeof substituted === "object") {
                        // Cas de boucle (itération sur un objet)
                        for (const key in substituted) {
                            if (substituted.hasOwnProperty(key)) {
                                const loopData = Object.assign(
                                    {},
                                    substituted[key],
                                    {
                                        _key: key,
                                        _value: substituted[key],
                                    }
                                );
                                let renderedBlock = substitute(
                                    innerTemplate,
                                    loopData,
                                    settings
                                ).trim();
                                const uniqueId = "potion_" + uniqueCounter++;
                                localContexts.set(uniqueId, loopData);
                                renderedBlock = renderedBlock.replace(
                                    /^\s*<([a-zA-Z0-9-]+)/,
                                    `<$1 data-potion-key="${uniqueId}"`
                                );
                                output += renderedBlock;
                            }
                        }
                    } else {
                        output += substituted;
                    }
                    index = j + 1; // Passer après le token de fermeture
                } else {
                    // Cas de substitution simple
                    output += substituted;
                    index++;
                }
            }
        }
        return output;
    }

    /**
     * Expose la Map des contextes locaux pour une utilisation externe.
     * @type {Map<string, Object>}
     */
    const localContextsMap = localContexts;

    /**
     * @module events
     */


    /**
     * Récupère le contexte local en remontant dans l'arborescence du DOM.
     *
     * @param {Element} element L'élément DOM sur lequel commencer la recherche.
     * @param {Object} defaultData Le contexte global par défaut.
     * @returns {Object} Le contexte local trouvé ou defaultData.
     */
    function getLocalContext(element, defaultData) {
        let el = element;
        while (el && el !== document.body) {
            const key = el.getAttribute("data-potion-key");
            if (key) {
                const context = localContextsMap.get(key);
                if (context !== undefined) {
                    return context;
                }
            }
            el = el.parentElement;
        }
        return defaultData;
    }

    /**
     * Convertit un argument textuel en sa valeur.
     *
     * @param {string} arg L'argument sous forme de chaîne.
     * @param {Object} data Les données à utiliser pour la résolution.
     * @returns {*} La valeur résolue.
     */
    function parseEventArgs(arg, data) {
        if (arg === "true") return true;
        if (arg === "false") return false;
        if (!isNaN(arg)) return Number(arg);
        const match = arg.match(/^["'](.*)["']$/);
        return match ? match[1] : data[arg] || arg;
    }

    /**
     * Lie les événements définis sur un élément en gérant les modifiers.
     *
     * @param {Element} element L'élément sur lequel binder les événements.
     * @param {Object} data L'objet global de données.
     */
    function bindEvents(element, data) {
        [...element.attributes]
            .filter((attr) => attr.name.startsWith("@"))
            .forEach((attr) => {
                const parts = attr.name.slice(1).split(".");
                const eventType = parts[0];
                const modifiers = parts.slice(1);
                const regex = /^(\w+)(?:\((.*)\))?$/;
                const match = attr.value.match(regex);
                if (!match) {
                    console.warn(
                        "Potion: impossible de parser l'expression de l'événement:",
                        attr.value
                    );
                    return;
                }
                const fnName = match[1];
                const argsStr = match[2] || "";
                const localData = getLocalContext(element, data);
                const args = argsStr
                    ? argsStr
                          .split(",")
                          .map((arg) => parseEventArgs(arg.trim(), localData))
                    : [];
                const callback =
                    typeof localData[fnName] === "function"
                        ? localData[fnName]
                        : typeof data[fnName] === "function"
                        ? data[fnName]
                        : null;
                if (typeof callback === "function") {
                    element.removeEventListener(
                        eventType,
                        element._boundEvents?.[eventType]
                    );
                    const handler = (event) => {
                        if (
                            modifiers.includes("self") &&
                            event.target !== event.currentTarget
                        )
                            return;
                        if (modifiers.includes("prevent")) event.preventDefault();
                        if (modifiers.includes("stop")) event.stopPropagation();
                        if (
                            modifiers.includes("stopImmediate") &&
                            event.stopImmediatePropagation
                        )
                            event.stopImmediatePropagation();
                        // Autres vérifications pour MouseEvent/KeyboardEvent...
                        const context = { ...data, ...localData };

                        callback.call(context, event, ...args);
                    };
                    element._boundEvents = {
                        ...element._boundEvents,
                        [eventType]: handler,
                    };
                    const options = {};
                    if (modifiers.includes("capture")) options.capture = true;
                    if (modifiers.includes("once")) options.once = true;
                    if (modifiers.includes("passive")) options.passive = true;
                    element.addEventListener(eventType, handler, options);
                } else {
                    console.warn(
                        `Potion: function '${fnName}' not found in local context or data.`
                    );
                }
                element.removeAttribute(attr.name);
            });
    }

    /**
     * @module dom
     */

    /**
     * Enregistre les références d'éléments dans un objet de données.
     * Les éléments doivent avoir un attribut "#ref".
     * @param {Element} container Le container du rendu.
     * @param {Object} data Les données de l'application.
     */
    function registerRefs(container, data) {
        const refs = {};
        // Recherche les éléments ayant l'attribut "#ref" dans le container
        container.querySelectorAll("[\\#ref]").forEach((el) => {
            const refName = el.getAttribute("#ref");
            if (refName) {
                refs[refName] = el;
                el.removeAttribute("#ref");
            }
        });
        data.$refs = Object.assign({}, data.$refs, refs);
    }

    /**
     * Compare deux nœuds DOM et met à jour l'ancien nœud en fonction des différences.
     *
     * @param {Node} oldNode Le nœud existant dans le DOM.
     * @param {Node} newNode Le nouveau nœud généré.
     */
    function diffNodes(oldNode, newNode) {
        if (
            oldNode.nodeType !== newNode.nodeType ||
            oldNode.nodeName !== newNode.nodeName
        ) {
            oldNode.parentNode.replaceChild(newNode.cloneNode(true), oldNode);
            return;
        }
        if (oldNode.nodeType === Node.TEXT_NODE) {
            if (oldNode.textContent !== newNode.textContent) {
                oldNode.textContent = newNode.textContent;
            }
            return;
        }
        if (oldNode.nodeType === Node.ELEMENT_NODE) {
            Array.from(newNode.attributes).forEach((attr) => {
                if (attr.name.startsWith("@") || attr.name.startsWith("#")) return;
                if (oldNode.getAttribute(attr.name) !== attr.value) {
                    oldNode.setAttribute(attr.name, attr.value);
                }
            });
            Array.from(oldNode.attributes).forEach((attr) => {
                if (attr.name.startsWith("@") || attr.name.startsWith("#")) return;
                if (!newNode.hasAttribute(attr.name)) {
                    oldNode.removeAttribute(attr.name);
                }
            });
            const oldChildren = Array.from(oldNode.childNodes);
            const newChildren = Array.from(newNode.childNodes);
            const max = Math.max(oldChildren.length, newChildren.length);
            for (let i = 0; i < max; i++) {
                if (i >= oldChildren.length) {
                    oldNode.appendChild(newChildren[i].cloneNode(true));
                } else if (i >= newChildren.length) {
                    oldNode.removeChild(oldChildren[i]);
                } else {
                    diffNodes(oldChildren[i], newChildren[i]);
                }
            }
        }
    }

    /**
     * Met à jour le DOM en comparant un HTML généré avec l'état actuel.
     *
     * @param {Element} containerElement L'élément container du rendu.
     * @param {string} newHTML Le nouveau HTML généré.
     */
    function updateDOM(containerElement, newHTML) {
        const tagName = containerElement.tagName.toLowerCase();

        const parser = new DOMParser();
        const newDoc = parser.parseFromString(
            `<${tagName}>${newHTML}</${tagName}>`,
            "text/html"
        );
        const newContainer = newDoc.body.firstChild;

        // Recopier les attributs du container existant
        [...containerElement.attributes].forEach((attr) => {
            newContainer.setAttribute(attr.name, attr.value);
        });

        diffNodes(containerElement, newContainer);
    }

    /**
     * @module reactivity
     */

    /**
     * Cache pour stocker les proxys déjà créés pour chaque objet.
     * WeakMap permet de ne pas empêcher la collecte de déchets.
     */
    const proxyCache = new WeakMap();

    /**
     * Crée un Proxy réactif profond pour observer un objet donné.
     * Optimisé en utilisant un cache pour éviter de créer plusieurs proxies pour le même objet.
     *
     * @param {Object} target L'objet à observer.
     * @param {Function} onChange Callback appelée lors d'une modification.
     * @param {number} [maxDepth=Infinity] Profondeur maximale d'observation.
     * @param {number} [currentDepth=0] (Usage interne) Profondeur actuelle.
     * @returns {Object} Le Proxy réactif.
     */
    function deepProxy(
        target,
        onChange,
        maxDepth = Infinity,
        currentDepth = 0
    ) {
        if (typeof target !== "object" || target === null) return target;
        // Si la profondeur maximale est atteinte, renvoyer l'objet sans Proxy
        if (currentDepth >= maxDepth) return target;

        // Vérifier si le Proxy existe déjà pour cet objet
        if (proxyCache.has(target)) {
            return proxyCache.get(target);
        }

        const proxy = new Proxy(target, {
            get(obj, prop) {
                const value = Reflect.get(obj, prop);
                // Proxyfier récursivement en augmentant la profondeur
                return deepProxy(value, onChange, maxDepth, currentDepth + 1);
            },
            set(obj, prop, value) {
                const oldValue = obj[prop];
                const result = Reflect.set(obj, prop, value);
                if (oldValue !== value) {
                    onChange();
                }
                return result;
            },
        });
        proxyCache.set(target, proxy);
        return proxy;
    }

    let templates = {};
    let initialized = false;

    const defaultSettings = {
        start: "[",
        end: "]",
        path: "[^\\]]+",
        type: "template/potion",
        attr: "data-name",
        tag: "div",
        class: "",
    };

    let settings = { ...defaultSettings };

    if (typeof window !== "undefined") {
        // scan le dom pour les templates de type template/potion
        document
            .querySelectorAll(`template[type="${settings.type}"]`)
            .forEach((el) => {
                const templateName = el.getAttribute(settings.attr);
                templates[templateName] = el.innerHTML;
            });
    }

    /**
     * Rendu de template depuis une chaîne ou un template en cache.
     *
     * @param {string} template - La chaîne du template ou le templateName en cache.
     * @param {Object} data - Les données pour la substitution.
     * @returns {string} Le template rendu.
     */
    function Potion(template, data) {
        // Injecter $store dans les données
        data = extendStore(data);
        if (!initialized) {
            initialized = true;
            applyFilter("init", template, data);
        }
        template = applyFilter("templateBefore", template, data);
        if (!template.includes(settings.start)) {
            template = templates[template] || template;
        }
        template = applyFilter("template", template, data);
        if (template && data !== undefined) {
            template = safeSubstitute(template, data, settings);
        }
        return applyFilter("templateAfter", template, data);
    }

    /**
     * Crée un conteneur à partir d'un template HTML présent dans le DOM.
     *
     * @param {HTMLTemplateElement} templateElement - L'élément template.
     * @param {Object} data - Les données pour le rendu.
     * @returns {Element} Le conteneur créé.
     */
    function createContainerFromTemplate(templateElement, data, customSettings) {
        customSettings = { ...settings, ...customSettings };

        // Injecter $store dans les données
        data = extendStore(data);
        const renderedHTML = Potion(
            templateElement.innerHTML,
            data);
        let container;

        if (customSettings.tag && isValidHTMLElement(customSettings.tag)) {
            container = document.createElement(customSettings.tag);
        } else {
            container = document.createElement(settings.tag);
        }
        container.innerHTML = renderedHTML;

        [...templateElement.attributes].forEach((attr) => {
            if (attr.name !== "type") {
                container.setAttribute(attr.name, attr.value);
            }
        });

        if (customSettings.class) {
            container.classList.add(...customSettings.class.split(" "));
        }

        data.$root = container;

        registerRefs(container, data);

        bindEvents(container, data);
        container.querySelectorAll("*").forEach((child) => bindEvents(child, data));

        templateElement.parentNode.replaceChild(container, templateElement);
        return container;
    }

    /**
     * Rendu synchrone avec réactivité.
     *
     * @param {string} templateName - Le nom du template.
     * @param {Object} data - Les données.
     * @returns {Object} L'objet réactif.
     */
    function renderSync(templateName, data, customSettings) {
        const templateElement = document.querySelector(
            `template[data-name='${templateName}']`
        );
        if (!templateElement) {
            throw new Error(
                `Potion: template with name '${templateName}' not found`
            );
        }

        // Injecter $store dans les données
        data = extendStore(data);

        const originalTemplateContent = templateElement.innerHTML;

        // Déclare une fonction mutable pour onChange
        let onChangeCallback = () => {};

        // Crée le proxy avec un callback qui délègue à onChangeCallback
        const proxy = deepProxy(data, () => {
            onChangeCallback();
        });

        // Crée le container en passant le proxy (qui sera utilisé pour le rendu initial)
        const containerElement = createContainerFromTemplate(
            templateElement,
            proxy,
            customSettings
        );

        // Maintenant, on définit onChangeCallback pour utiliser containerElement
        onChangeCallback = () => {
            const updatedHTML = Potion(originalTemplateContent, proxy);
            updateDOM(containerElement, updatedHTML);
            bindEvents(containerElement, proxy);
            containerElement
                .querySelectorAll("*")
                .forEach((child) => bindEvents(child, proxy));
        };

        return proxy;
    }

    /**
     * La fonction principale 'potion' qui effectue un rendu ponctuel.
     *
     * @param {string} template - Le template sous forme de chaîne.
     * @param {Object} data - Les données pour le rendu.
     * @returns {string} Le template rendu.
     */
    function potion(template, data) {
        return Potion(template, data);
    }

    potion.sync = renderSync;
    potion.render = function (templateName, data, customSettings) {
        const templateElement = document.querySelector(
            `template[data-name='${templateName}']`
        );
        if (!templateElement)
            throw new Error(
                `Potion: template with name '${templateName}' not found`
            );
        return createContainerFromTemplate(templateElement, data, customSettings);
    };

    potion.addFilter = addFilter;
    potion.applyFilter = applyFilter;

    return potion;

})();
